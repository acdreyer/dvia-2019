## Clock Project 

### Introduction

This assignment is detailed on the [course page](https://dvia.samizdat.co/2019/right-twice-a-day/).
Additional details are given in the course [schedule](https://dvia.samizdat.co/2019/tag/schedule/).

The assignment included design of a clock to visualize times, dates and seasons in various
ways by mapping Bertin retinal variables to numbers returned from a clock (time) 
function.

### Explanation

The first three clocks used various means to visualize time and the latter implementations
were used to map calendar items. However, this final task combines all these into
a single clock. The main challenge was to combine diverging concepts, especially 
since previously the designs had a minimalist approach.

### Time

The final implementation of the time/clock uses a circle (sphere) with lines accross
it's surface that move according to **seconds**, **minutes** and **hours**. These lines are
offset 120 degrees from each other to allow for symmetry and maximum visual effect.
The concept of moving lines come from the first line clock that maps line **positions**
through the seconds, minutes and hour values to lateral and vertical position.
However, this spherical implementation merges the position with **orientation**
to maximize the visual effect.

The horizontal line is the hours of the day, counting from zero to twelve, where
twelve o'clock the line is at the top. The line moving from top left to bottom right
corresponds to 60 minutes (bottom right being 60 minutes) 
and the line moving from bottom left to top right is the seconds (top right being 60 seconds).
For each the clock function `now.progress` output is used; more specifically the
`now.progress.min`, `now.progress.hour` and `now.progress.halfday`.

### Week day

The **day of the week** has been implemented by leafy shapes that count the number of days;
using the retinal variable of **shape** and **texture**. For every day of the week a leaf
is added to each of the pattern shapes.

The progress of seasons and year is presented by texture and colour through adding and subtracting
leafy clusters randomly throughout the year to indicate the slow change over time.
The colour is mapped per season using the `chroma.js` function as well as discrete **colour**
values. In order to get a smooth transition, **value** is used in addition to 
randomly populating the **texture**. 


In order to control the mapping of the progress through the year, a cosine function
was used to generate a numerical output inbetween 0 and 1 that will rise and fall
as a particular season approaches. The yearly progress is therefore aggregated
accross seasons using the `now.season` number and `now.progress.season` number
to create a continuous spectrum over the year in order to map **texture** 
creation. 


The texture is in turn generated by a custion leaf plotting function that maps
leaves using a for loop up to a maximum number/resolution as limited by the 
continuous transition where seasons overlap. This makes it possible to have
multiple seasons represented concurrently and scaled visually through "adding
and subtracting" leafy clusters randomly.










